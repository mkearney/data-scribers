<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sohlichgithubio on DATA SCrIbers</title>
    <link>/tags/sohlichgithubio/</link>
    <description>Recent content in Sohlichgithubio on DATA SCrIbers</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/sohlichgithubio/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang</title>
      <link>/post/golang/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/golang/</guid>
      <description>I&amp;rsquo;m using Golang for a while. During the development, I was used to repeatedly execute &amp;ldquo;go build&amp;rdquo;,&amp;ldquo;go test&amp;rdquo; manually. This was a bad habit on which I resign. It is not so painful if you use simple command without any args. But in case of more complex tasks, naturally, it is going to be a pain. There are few options you can consider as a way out. You can use a bash script to do the work for&amp;hellip;</description>
    </item>
    
    <item>
      <title>Deploy on Clever Cloud with Bitbucket Pipelines</title>
      <link>/post/deploy-on-clever-cloud-with-bi/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/deploy-on-clever-cloud-with-bi/</guid>
      <description>First, we need to add a Dockerfile to application folder (for the simplicity). The most simple Dockerfile could look like following one. The important step in Dockerfile is the exposing of port 8080. The Clever Cloud requires this port as a default HTTP port. If the application does not respond on this port, the monitor tool evaluates the application as non-working and the deployment&amp;hellip;</description>
    </item>
    
    <item>
      <title>Angular on Electron, part 2</title>
      <link>/post/angular-on-electron-part-2/</link>
      <pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/angular-on-electron-part-2/</guid>
      <description>In the previous post the bootstrap of Angular project on Electron platform was described. In this one, the process of application packaging will be presented. One of the benefits of Electron is that it runs on all major platforms. Each platform has naturally its needs regarding to creating the distribution package. Fortunately, the packaging and all that stuff do not need to be done&amp;hellip;</description>
    </item>
    
    <item>
      <title>Angular on Electron, part 1</title>
      <link>/post/angular-on-electron-part-1/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/angular-on-electron-part-1/</guid>
      <description>Today it is possible to have almost all the applications as a service online. Literally you don&amp;rsquo;t have to install any of it on you computer. Even if this is possible, but for me it is still more comfortable to have a dedicated desktop application. I believe I&amp;rsquo;m not the only one. There are a lot of ways how to create a desktop&amp;hellip;</description>
    </item>
    
    <item>
      <title>Streaming JSON with Jackson</title>
      <link>/post/streaming-json-with-jackson/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/streaming-json-with-jackson/</guid>
      <description>Sometimes there is a situation, when it is more efficient to parse the JSON in stream way. Especially if you are dealing with huge input or slow connection. In that case the JSON need to be read as it comes from input part by part. The side effect of such approach is that you are able to read corrupted JSON arrays in some kind of comfortable&amp;hellip;</description>
    </item>
    
  </channel>
</rss>